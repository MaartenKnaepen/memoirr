# Implementation Memory

## Phase 1: Foundation

### Step 1.1: Configuration Updates (Completed)
Added V1 multimodal configuration settings to `src/core/config.py` including metadata API settings (TMDB, Radarr, Plex), vision pipeline settings (scene detection, face recognition, VLM model configuration), and speaker tagging settings. Updated `pyproject.toml` with new dependencies (scenedetect, opencv-python, qwen-vl-utils, guessit, pillow, accelerate, requests). Created `.env.example` template and comprehensive test suite in `test/core/test_v1_config.py` with 18 passing tests covering defaults and validation.

### Step 1.2: Type Definitions (Completed)
Created frozen dataclasses for V1 Foundation type system. Defined `CastMember` and `MovieMetadata` in `src/components/metadata/utilities/types.py` for movie metadata from TMDB/Radarr/Plex. Defined `FaceDetection`, `FaceCluster`, `VisualDescription`, and `Scene` in `src/components/vision/utilities/types.py` for vision pipeline stages. All types follow immutability pattern with `@dataclass(frozen=True)`, proper type hints, Google-style docstrings, and default factories. Fixed `.gitignore` to track empty directories. Created comprehensive test suite in `test/components/test_v1_types.py` with 17 passing tests covering creation, defaults, and immutability. Package structure established with proper `__init__.py` exports for both metadata and vision components.

### Step 1.3: TMDB Client Implementation (Completed)
Implemented `TmdbClient` following the 3-layer architecture pattern. Created `api_request.py` utility for HTTP requests with error handling, rate limiting, and retries. Created `response_parser.py` utility for parsing TMDB JSON responses into frozen dataclasses. Created `orchestrate_tmdb.py` orchestrator for coordinating search and metadata fetching operations. Created `tmdb_client.py` wrapper class that manages API key configuration and provides clean interface methods: `search_movie()`, `get_movie_metadata()`, and `get_movie_metadata_by_id()`. Comprehensive test suite with 34 passing tests covering API requests, response parsing, orchestration, and client wrapper functionality. All tests use proper mocking patterns with `unittest.mock` and `LoggedOperation` mocks.

### Step 1.4: Radarr Client Implementation (Completed)
Implemented `RadarrClient` following the 3-layer architecture pattern. Created `api_request.py` utility for HTTP requests with X-Api-Key authentication, connection error handling (for local Radarr servers), and 401 unauthorized detection. Created `response_parser.py` utility for parsing Radarr JSON responses into `MovieMetadata` objects and extracting file paths from movieFile fields. Created `orchestrate_radarr.py` orchestrator providing `get_all_movies()` and `get_movie_by_tmdb_id()` operations. Created `radarr_client.py` wrapper class with methods: `get_all_movies()`, `get_movie_by_tmdb_id()`, `get_movie_by_radarr_id()`. Configuration loaded from `RADARR_URL` and `RADARR_API_KEY` environment variables (already present in config.py). All tests passing (34 tests: 24 utility tests + 10 component tests). Note: Radarr doesn't provide cast information - use `TmdbClient` to enrich metadata with cast details. Exported `RadarrClient` from `src/components/metadata/__init__.py`.

### Step 1.5: Plex Client Implementation (Completed)
Implemented `PlexClient` following the 3-layer architecture pattern. Created `api_request.py` utility for HTTP requests with X-Plex-Token authentication and Accept: application/json header. Created `response_parser.py` utility for parsing Plex's nested MediaContainer JSON responses, extracting server identity, movie metadata, TMDB IDs from guids, cast/genre info, and file paths from Media > Part structure. Created `orchestrate_plex.py` orchestrator providing `get_server_identity()`, `search_plex

### Step 1.6: Metadata Service Implementation (Completed)
Implemented `MetadataService` Haystack component as the capstone of Phase 1. It integrates `TmdbClient`, `RadarrClient`, and `PlexClient` to resolve file paths to rich metadata. Created `orchestrate_metadata.py` orchestrator implementing the "Plex-First" strategy with Radarr fallback: (1) Try Plex to get rating_key and tmdb_id by file path, (2) Fall back to Radarr if Plex fails, (3) Fetch complete metadata from TMDB, (4) Enrich with plex_rating_key and radarr_id. Created `metadata_service.py` Haystack component with `@component.output_types(metadata=MovieMetadata)` that wraps the orchestration logic. Updated `src/components/metadata/__init__.py` to export `MetadataService`. Created comprehensive test suite with 11 tests covering initialization, happy paths (Plex hit, Radarr fallback), error cases (all miss, connection errors), and Haystack integration.

### Step 1.7: Metadata Service Refinement - Plex-Only Strategy (Completed)
Simplified architecture to "Plex-Only" strategy. Removed `RadarrClient` from `MetadataService` since if a movie isn't in Plex, we can't deep-link to it anyway. Modified `metadata_service.py` to remove RadarrClient instantiation and imports. Updated `orchestrate_metadata.py` to remove `radarr_client` argument, delete `_try_radarr_lookup` and `_normalize_path` functions, and fail fast with `ValueError("File not found in Plex library: {path}")` if Plex lookup returns None. Updated tests in `test_metadata_service.py` to remove all Radarr mocking and test the new fail-fast behavior. This creates a cleaner, strictly defined metadata pipeline with Plex as the single source of truth for file inventory.
